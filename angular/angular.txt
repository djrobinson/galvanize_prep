Okay, so I've run into an issue with my trade interface app where I can't get the javascript graphs to load via angular.  From SO questions online I've found, I'll need to build a directive passing the options to the view, but I"m not exactly sure what that means.  I need to take a step back and look at angular for a while to start wrapping my head around how this works.

I'm going to get started by reading the Angular docs.  I think this will probably take me two days.  I'll only post notes for today since I didn't get any material code done other than angular snippets.


Controllers: Sets up the initial state of the $scope object and add behavior to scope.

They do NOT interact directly (manipulate) the DOM, Format input, filter output, share code across other controllers, or manage other components (it should not create service instances).

var myApp = angular.module('myApp',[]);

myApp.controller('GreetingController', ['$scope', function($scope) {
  $scope.greeting = 'Hola!';
}]);

//  ^ Attaches greeting property to the scope sent to the ng-controller command

<div ng-controller="GreetingController">
  {{ greeting }}
</div>

Controllers can send functions to the view and take arguments in controller functions

Services: Business Logic that doesn't belong in the controller. Good to share code across the app and wired together with DI.

Lazily instantiated
Singleton

Lazy - Only instantiates a service when the application calls on it specifically
Singleton - Each component dependent on a service gets a reference to a single instance generated by the service factory
(meaning service factory will generate unique instance of the service for the caller)

Service factory function (myModule.factory()), creates a single instance of a the service (creating an object or function that will be reperesented to you application

You must register a service with the module api, and you can also declare dependencies for a service just like you would a module:

For example: batchModule service relie

batchModule.factory('batchLog', ['$interval', '$log', function($interval, $log) {
  var messageQueue = [];

  function log() {
    if (messageQueue.length) {
      $log.log('batchLog messages: ', messageQueue);
      messageQueue = [];
    }
  }

  // start periodic checking
  $interval(log, 50000);

  return function(message) {
    messageQueue.push(message);
  }
}]);

This requires the batchLog service

You can also register a service with $provide.factory inside the modules config section.

Scopes: Refers to the application model. It is the execution context for expressions. They also are arranged in a heirarchal structure which mimics the DOM.  Finally, scopes can watch expressions and propogate events.

Characteristics:

$watch : watches model mutations
$apply : propogates model mutations through the system into the view from outside of the "Angular Realm"

they can be nested for privacy

Scope is the glue between the application controller and the view.

Each application only has one root scope, but can have many child scopes.

Scopes can propogate events by broadcasting to scope children or emitting to scope parents

Need to understand the following lifecycle:

Scope Life Cycle
The normal flow of a browser receiving an event is that it executes a corresponding JavaScript callback. Once the callback completes the browser re-renders the DOM and returns to waiting for more events.

When the browser calls into JavaScript the code executes outside the Angular execution context, which means that Angular is unaware of model modifications. To properly process model modifications the execution has to enter the Angular execution context using the $apply method. Only model modifications which execute inside the $apply method will be properly accounted for by Angular. For example if a directive listens on DOM events, such as ng-click it must evaluate the expression inside the $apply method.

After evaluating the expression, the $apply method performs a $digest. In the $digest phase the scope examines all of the $watch expressions and compares them with the previous value. This dirty checking is done asynchronously. This means that assignment such as $scope.username="angular" will not immediately cause a $watch to be notified, instead the $watch notification is delayed until the $digest phase. This delay is desirable, since it coalesces multiple model updates into one $watch notification as well as guarantees that during the $watch notification no other $watches are running. If a $watch changes the value of the model, it will force additional $digest cycle.

Creation

The root scope is created during the application bootstrap by the $injector. During template linking, some directives create new child scopes.

Watcher registration

During template linking directives register watches on the scope. These watches will be used to propagate model values to the DOM.

Model mutation

For mutations to be properly observed, you should make them only within the scope.$apply(). Angular APIs do this implicitly, so no extra $apply call is needed when doing synchronous work in controllers, or asynchronous work with $http, $timeout or $interval services.

Mutation observation

At the end of $apply, Angular performs a $digest cycle on the root scope, which then propagates throughout all child scopes. During the $digest cycle, all $watched expressions or functions are checked for model mutation and if a mutation is detected, the $watch listener is called.

Scope destruction

When child scopes are no longer needed, it is the responsibility of the child scope creator to destroy them via scope.$destroy() API. This will stop propagation of $digest calls into the child scope and allow for memory used by the child scope models to be reclaimed by the garbage collector.


Dependency Injection: Just re-read the section.  There are a lot of software design principles here that I'm not fully comfortable with.  Here's the link: https://docs.angularjs.org/guide/di
 
Templates: templates are HTML docs that contain references to angular-specific elements and attributes

Expressions: Expressions are JS-like code snippets that are ussually place in double curly braces (bindings)

Filters:

Forms:

Directives:

One thing that I struggled with while starting angular practice was there was a huge learning curve just to get a simple app running.  Angular requires a web server to be running when you're working in test, because there is communication between files that is considered cross server scripting.

http://stackoverflow.com/questions/27742070/angularjs-error-cross-origin-requests-are-only-supported-for-protocol-schemes

Okay, enough angular notes.  Directives are really hard to understand so I'm going to knock out a couple of tutorials before finishing.


AngularJS Android Phone selection tutorial

Bootstrap - the piece of code that begins an application.  For angular that would be the ngApp directive (shows as ng-app in the view)

ng-app is what starts the application.  By adding your app module name from the main controller you will start up your app when the html loads.

The $ prefix is there to namespace Angular-provided services. To prevent collisions it's best to avoid naming your services and models anything that begins with a $.

Okay, I've done a ton of reading on Angular and I'm not feeling any better about it.  After running through a few tutorials, I at least have an example that i can cheat off of.

I've downloaded the angular-seed project.  Let's see if I can pull together a few quick apps. First I'll create the simple text input data binding example.

Let's get down to business and actually work through these damn docs. For starters, I downloaded the angular-seed project for the following example.  Angular is tough to wrap your head around at the start, since getting up and running can be somewhat difficult. There is a huge learning curve to simply understanding the runtime environment for angular, which has really tripped me up as a beginner.  I was introduced to angular as a front end framework but I never really understood how it differed from something like JQuery.  After a few hours of reading documentation, I wanted to try out a few Angular features so I threw together a controller, included it in my application, but ended up getting the following error:

CSRF Attack

The reason why this didn't work out is because Angular is much more than a few commands you can throw into your application.  Angular is a framework for building full blown applications, and it compiles all of the included angular expressions into html pages that are then updated in real time as the application runs.  What this means isthat Angular will automatically make updates to the DOM thanks to their 2 way data-binding features, however, this means that when we are in dev, we'll need to fire up a web server to get things runnign without the CSRF error.  Otherwise, our angular app will look like cross site scripting to our browser.

So perhaps I bit off more than I can chew here, but we'll need to learn about a few pre-requisite tools before we dive into Angular.  These tools will make running our Angular app on a web server quick and simple.

npm: Pulls in node modules required for running & testing our angular application.
Bower: Front end dependency management (elaborate)
karma: Front end test runner

Let's get our seed project set up with the tools above.  We'll use the official angular-seed project on Github as a guide for this tutorial:

https://github.com/angular/angular-seed

This tutorial has ridiculously simple instruction to get you up and running. The bower.json file and the package.json file are already set up to pull in each dependency when you run 'npm install'.

Okay, before we put down any code we'll need a conceptual understanding of how Angular creates, changes, and organizes data.  Angular is exclusively front-end, however, there is still an independent application Model that exists only on the front-end of our application.  This 'Model' is the Angular $scope object, and it serves as the intermediary data store between the view of your applicaiton and your angular controllers.  Angular is an MVC framework that only  operates on the front end. As a beginner, I tend to associate M with their database, you'll need to recognize the difference in this scenario.  The M in angular is the $scope object where your DOM heirarchy is maintained and modified by the $scope API. Scopes have a $watch and $apply method, which watch for model mutations and propogate (or apply) any changes from outside of the Angular app to our model. Let's take a look at how this works.  We'll take an example from the docs to show:

https://docs.angularjs.org/guide/scope

angular.module('scopeExample', [])
.controller('MyController', ['$scope', function($scope) {
  $scope.username = 'World';

  $scope.sayHello = function() {
    $scope.greeting = 'Hello ' + $scope.username + '!';
  };
}]);

<div ng-controller="MyController">
  Your name:
    <input type="text" ng-model="username">
    <button ng-click='sayHello()'>greet</button>
  <hr>
  {{greeting}}
</div>

So we're skipping very far ahead, but you need to do this in some way when learning angular, since Angular concepts are prerequisite knowledge to understanding Angular syntax, and Angular syntax is prerequisite knowledge to learning angular concepts (Hell of a catch, that Catch 22).

So what's happening above?  We're createing an angular module which will contain the business logic for our applicaiton which is stored in a controller (Modules and controllers are created using .module() and .controller()).  We name our Controller 'MyController' and our module 'scopeExample'.  We'll then include the 'scopeExample' module in our app (not shown), and make our html page use the 'MyController' controller to feed the business logic.  Inside of our controller, we begin to assign our desired data to the $scope object so that we can set its initial state.

Our controller is a constructor function that has the following esponibilities:

Set up the intial state of the $scope object
Add behavior to the $scope object

In this case, we've done both.  We have given the scope the intiial username of 'World' and we have also defined a method that can be used by the view as sayHello().

Now that this is done, let's get it set up in our browser.  Let's jump into our new Angular seed project.  Delete everything but the bower_components and the components folders in the in the /app folder.  Next, create a index.html and an app.js file and add the following code:

index.html:

<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en" ng-app="myApp" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en" ng-app="myApp" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en" ng-app="myApp" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en" ng-app="scopeExample" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>My AngularJS App</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="bower_components/html5-boilerplate/dist/css/normalize.css">
  <link rel="stylesheet" href="bower_components/html5-boilerplate/dist/css/main.css">
  <link rel="stylesheet" href="app.css">
  <script src="bower_components/html5-boilerplate/dist/js/vendor/modernizr-2.8.3.min.js"></script>
</head>
<body>


<div ng-controller="MyController">
  Your name:
    <input type="text" ng-model="username">
    <button ng-click='sayHello()'>greet</button>
  <hr>
  {{greeting}}
	<hr>

</div>	

  <div>Angular seed app: v<span app-version></span></div>

  <!-- In production use:
  <script src="//ajax.googleapis.com/ajax/libs/angularjs/x.x.x/angular.min.js"></script>
  -->
  <script src="bower_components/angular/angular.js"></script>
  <script src="bower_components/angular-route/angular-route.js"></script>
  <script src="app.js"></script>
  <script src="components/version/version.js"></script>
  <script src="components/version/version-directive.js"></script>
  <script src="components/version/interpolate-filter.js"></script>
</body>
</html>

Then we'll need to briefly introduce controllers in order to understand how we can add data to our views. Controllers set up the initial state of the $scope object and add behavior to scope.

They do NOT interact directly (manipulate) the DOM, Format input, filter output, share code across other controllers, or manage other components (it should not create service instances). That's where our $scope object will be most effectively used, which we'll see examples of shortly. 

app.js:

angular.module('scopeExample', [])
.controller('MyController', ['$scope', function($scope) {
  $scope.username = 'World';

  $scope.sayHello = function() {
    $scope.greeting = 'Hello ' + $scope.username + '!';
  };
}]);

So as you can tell, this is the Angular Docs example added to our seed project.  At the bottom you can see the two scope items in our controller, and our app uses the scopeExample app and provides the 'MyController' controller to the view.  Now to understand how data is shared between the view and the controller via scope, do the following:

Right click on the input box and select "inspect element"
Switch to the browser console and run: angular.element($0).scope()
Expand  '$$watchers: Array[2]'

Do you see our username and sayHello funciton show up? Before we even click anything, Angular has injected the $scope data into the view and it available for use anwhere in the view. However, this scope object isn't just pulling straight from the controller.  The scope is independent from the controller and is able to be changed via the view. Let's Change "World" to "Folks" and run the same browser console command.

You'll find that the watchers object has now changed the corresponding entries to username to "Folks" and it now appears in the text below the input box.

The beauty of the $scope object is it's a model that can be shared between the controller and the view to keep all of the data in the app in sync. This is a perfect segue into our two way data-binding concept that is abslutey critical to understand so you can see why angular is so cool.

Time to drop the 'greet' button.  We could do that crap with JQuery after all.  Let's start firing up Angular and using it to its fullest potential.

So to see how two way data binding works, let's think about how the request response lifecycle works with a webpage.  Before angular, when you wanted to update the view with logic, you would need to make a roundtrip request to teh server, resulting in a page load.  However, thanks to the $scope's $watch and $apply API methods, our view data that is dependent on controller logic is updated automatically.  Do you remember the whole $$watchers array that you saw in the console?  This lists the objects from the controller that are paying attention to your view for model mutations.  As you make changes (either from the view or to the controller via commands outside the Angular realm), the $watch method immediately syncs your changes between the controller and the view.  This is called 2-way data binding.  To see it in action, we are going to delete the 'greet' button, and change the {{greeting}} expression to {{username}}.  Now reload the page.

This looks like an incomplete application.  In the old web, we would normally need a button to make an input box do anything.  But go ahead and modify the text in the input box.  See how it automatically updates?  Angular's $scope object keeps the view and model in sync the very moment we start to type.  Cool right?

In the Angular application lifecycle, there are 4 major steps in startup. First, upon startup, the HTML for the main template is loaded into the page.  At this point, the Angular expressions and directives have not yet been evaluated.  The first step simply loads the Angularjs scripts and then registers the controllers which you are dependent on based on what modules you have injected into your main app. The global scope is created for use between your angular controllers and views.

The second step is Angular running through your HTML template to find any known Angular apps or views (noted by ng-app or ng-view).  It will then load the appropriate app or view based on what is declared.

The third step is the execution of controller functions.  So this will be where the views render with the appropriate value based off what the Angular controller demands that you do.

Finally, our $watch & $apply magic begins. Once the initial $scope values from the relevant controller are rendered in the view during step 3, our ng-scope lifecycle kicks (or the $digest loop). During step 4 every $scope object that is used in the view is registered in the angular $watch list, so every time the $digest loop occurs, Angular will 'dirty-check' every item in the $watch list to see if there has been a change to the $scope object.

To better understand how Angular will check through your HTML template, we'll need to take a good look at the view 
components of angular: templates and directives.

https://www.ng-book.com/p/The-Digest-Loop-and-apply/

DIRECTIVES

Directives are markers in your html that tells Angular's HTML compiler to add behavior to or change DOM elements by setting up event listeners on each unique marker that can be tied back to a controller.

Angular has built in directives, but you can also create your own.  We will focus on how the $digest loop interacts with these directives during the application's lifecycle.

Directives are created using angular's api for registering directives. Directives are created using the .directive function much like Angular creates controllers using .controller() function.  Directives will allow you to create new HTML elements & tags so that you can tell angular that you need additional info.

So let's get an example going. Let's say I would like to create a quick application to keep track of my summer reading list. 

Let's setup a quick json file for the sake of testing.  Here's 4 books that we can use to start our develpoment process:

[
    {
        "age": 0, 
        "name": "fight-club", 
        "imageUrl": "img/books/fight-club.jpg", 
        "author": "Chuck Palunik", 
        "snippet": "A lesson in hitting rock bottom"
    }, 
    {
        "age": 1, 
        "name": "crime-and-punishment", 
        "imageUrl": "img/books/crime-and-punishment.jpg", 
        "author": "Fyodor Dostevsky", 
        "snippet": "A conflicting lesson in morality"
    },
     {
        "age": 2, 
        "name": "discoverers", 
        "imageUrl": "img/books/discoverers.jpg", 
        "author": "Daniel Boorstin", 
        "snippet": "A history of everything that has ever been created"
    },     
    {
        "age": 3, 
        "name": "sun-also-rises", 
        "imageUrl": "img/books/sun-also-rises.jpg",
        "author": "Ernest Hemingway", 
        "snippet": "The story of the Lost Generation"
    } 
]

Okay, now that this is done we will need to introduce how controllers set up the initial scope object and how directives will leverage controllers to populate their data during the $digest cycle.

To get this data showing up in the browser, we'll need to update our app.js file to pull the data.  We'll use and ajax call with $http.get to access the external json file for our application. We'll update our controller from the first example to do the following:

-create a bookListCtrl that depends on the $scope module and the $http module. 
-Our callback function will first call $http.get method to open up the books.json file that is in our app/books/ folder.
-If the get request is successful, we will return the data and set the $scope.books property to the json data that is returned from the file.
-Finally, we'll order the books by their 'age' property


We'll do a quick update to our html page in the body like so:

<div ng-controller="BookListCtrl">

	<ul class="books">
		<li ng-repeat="book in books | orderBy:orderProp">
			<a class="picture"><img ng-src="{{ book.imageUrl }}"></a>
			<p>{{ book.title }} </p>
		</li>
	</ul>

</div>	

So while this doesn't seem like a huge departure from our last example, we can now point out that we are using directives already in this scenario.  We use the ng-repeat directive to tell Angular to repeat through the entire list of books.  Then we use 2 interpolation directives (anything inside {{ }}) to evaluate book.imageUrl and book.title.  

Angular has built in directives which make it very easy for you to explain to Angular how to get your controller information into the view.  These directives are based of the most common requirements for retrieving data from the controller:

interpolation directive: Inserts the result of an expression into and html template.  Evaluate anything within {{ }}.  Can return a function or property.
Example:
<div ng-controller="MyController" >
    <span>{{myData.text}}</span>
</div>

ng-bind directive: Alternative to interpolation. Same exact usage without the curly pair:
<div ng-controller="MyController" >
  <span ng-bind="myData.textf()"></span>
</div>

ng-show/ng-hide: Shows an html element depending on data in the model:

  <div ng-controller="MyController" >
      <span ng-show="myData.showIt"></span>
      <span ng-hide="myData.showIt"></span>
  </div>

  <script>
    angular.module("myapp", [])
    .controller("MyController", function($scope) {
      $scope.myData = {};
      $scope.myData.showIt = true;
    });
  </script>
  
ng-switch: Will add or remove html elements in DOM based on data in the model.  

<div ng-controller="MyController" >
    <div ng-switch on="myData.switch">
        <div ng-switch-when="1">Shown when switch is 1</div>
        <div ng-switch-when="2">Shown when switch is 2</div>
        <div ng-switch-default>Shown when switch is anything else than 1 and 2</div>
    </div>
</div>

<script>
    angular.module("myapp", [])
    .controller("MyController", function($scope) {
      $scope.myData = {};
      $scope.myData.switch = 3;
    });
</script>
ng-if: Similar to switch but with simpler syntax:

<div ng-controller="MyController" >
    <div ng-if="myData.showIt">ng-if Show it</div>
</div>

<script>
    angular.module("myapp", [])
    .controller("MyController", function($scope) {
        $scope.myData = {};
        $scope.myData.showIt = true;
    });
</script>

ng-include: Used to include a specified template:

<div ng-controller="MyController" >
    <div ng-include="'angular-included-fragment.html'"></div>
</div>

ng-repeat: runs through listed data from the controller to display the list properties in the view:

<ol>
   <li ng-repeat="theItem in myData.items">{{theItem.text}}</li>
</ol>

<script>
    angular.module("myapp", [])
    .controller("MyController", function($scope) {
        $scope.myData = {};
        $scope.myData.items = [ {text : "one"}, {text : "two"}, {text : "three"} ];
    });
</script>

FILTERS

Filtering is a good follow up to directives.  Filters can be applied to directives in order to hide or show specific data points to the view.  The basic syntax looks like so:

<div ng-repeat="item in myData.items | filter: itemFilter"></div>

There are 3 different built in filters that you can use for lists of data:

limitTo
filter
orderBy

We are already using the orderBy filter, but let's play around with some more specific filters. We'll need to set up the filter in our controller to be able to actually use a filter:

//here i'll just need to do a simple if age < 2 return true, else return false

Okay, now let's do somethign interactive.  Angular's filter function will automatically match our text to our repeated data's properties that will be appearing in the view and filters out everything that doesn't match our query text.  All it takes is simply adding the following query box and filter into our directive:

<div class="container-fluid">
	<div class="row">
		 <div class="col-md-2">
		   <!--Sidebar content-->

		   Search: <input ng-model="query">  //added query search funnction

		 </div>
			<div ng-controller="BookListCtrl" class="col-md-10">

				<ul class="books">
					<li ng-repeat="book in books | orderBy:orderProp | filter:query">  //added query filter
						<a href="#/books/{{ book.name }}" class="picture"><img ng-src="{{ book.imageUrl }}"></a>
						<p>{{ book.title }} </p>
						<p>{{ book.snippet }} </p>
					</li>
				</ul>

			</div>	
	</div>
</div>

http://tutorials.jenkov.com/angularjs/watch-digest-apply.html

CUSTOM DIRECTIVES

Okay, now let's get into some really cool stuff angular has to offer.  Angular's website has the tagline "HTML enhanced for webapps".  So far, we've seen angular simply as a framework that builds applications around HTML, but it can do much more involved things with HTML that open up a whole new world of possiblities.  Angular's custom directives allow us to build brand new HTML & CSS elements, attributes, and classes that you can use to extend HTML's existing functionality.  So with directives you are able to create elements that are specific to your application like:

<my-directive>{{ data.goes.here }}</my-directive>

Here are the 4 types of custom directives you can create:

Element directives
Attribute directives
CSS class directives
Comment directives

Generatlly you should stick to Element and Attribute directives unless absolutely neccessary.  However, all 4 are available to you.  Here's an example of how we would include a html template in the body of our example:

bookApp.directive('mygraph', function() {
	var directive = {};
	
	directive.restrict = 'E'; //Restricts to element directive
	directive.templateUrl = 'templates/graph.html';
	
	return directive;
});

then we'll need to create graph.html. YOu can put anything in here since right now the only purpose of the exercies iit to see that we can connect to an external template. Now by adding the <mygraph></mygraph> element into our html page, we should see the contents of graph.html show up in our main page.


Okay, this is a lot of angular crap to cover.  I think I'm going to switch gears to see if I can get those graphs working I was creating a few weeks back.  I think withthis understanding of angularr I've gained it should be easy to get the graphs together.

https://www.ng-book.com/p/The-Digest-Loop-and-apply/






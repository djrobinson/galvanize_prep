Okay, so I've run into an issue with my trade interface app where I can't get the javascript graphs to load via angular.  From SO questions online I've found, I'll need to build a directive passing the options to the view, but I"m not exactly sure what that means.  I need to take a step back and look at angular for a while to start wrapping my head around how this works.

I'm going to get started by reading the Angular docs.  I think this will probably take me two days.  I'll only post notes for today since I didn't get any material code done other than angular snippets.


Controllers: Sets up the initial state of the $scope object and add behavior to scope.

They do NOT interact directly (manipulate) the DOM, Format input, filter output, share code across other controllers, or manage other components (it should not create service instances).

var myApp = angular.module('myApp',[]);

myApp.controller('GreetingController', ['$scope', function($scope) {
  $scope.greeting = 'Hola!';
}]);

//  ^ Attaches greeting property to the scope sent to the ng-controller command

<div ng-controller="GreetingController">
  {{ greeting }}
</div>

Controllers can send functions to the view and take arguments in controller functions

Services: Business Logic that doesn't belong in the controller. Good to share code across the app and wired together with DI.

Lazily instantiated
Singleton

Lazy - Only instantiates a service when the application calls on it specifically
Singleton - Each component dependent on a service gets a reference to a single instance generated by the service factory
(meaning service factory will generate unique instance of the service for the caller)

Service factory function (myModule.factory()), creates a single instance of a the service (creating an object or function that will be reperesented to you application

You must register a service with the module api, and you can also declare dependencies for a service just like you would a module:

For example: batchModule service relie

batchModule.factory('batchLog', ['$interval', '$log', function($interval, $log) {
  var messageQueue = [];

  function log() {
    if (messageQueue.length) {
      $log.log('batchLog messages: ', messageQueue);
      messageQueue = [];
    }
  }

  // start periodic checking
  $interval(log, 50000);

  return function(message) {
    messageQueue.push(message);
  }
}]);

This requires the batchLog service

You can also register a service with $provide.factory inside the modules config section.

Scopes: Refers to the application model. It is the execution context for expressions. They also are arranged in a heirarchal structure which mimics the DOM.  Finally, scopes can watch expressions and propogate events.

Characteristics:

$watch : watches model mutations
$apply : propogates model mutations through the system into the view from outside of the "Angular Realm"

they can be nested for privacy

Scope is the glue between the application controller and the view.

Each application only has one root scope, but can have many child scopes.

Scopes can propogate events by broadcasting to scope children or emitting to scope parents

Need to understand the following lifecycle:

Scope Life Cycle
The normal flow of a browser receiving an event is that it executes a corresponding JavaScript callback. Once the callback completes the browser re-renders the DOM and returns to waiting for more events.

When the browser calls into JavaScript the code executes outside the Angular execution context, which means that Angular is unaware of model modifications. To properly process model modifications the execution has to enter the Angular execution context using the $apply method. Only model modifications which execute inside the $apply method will be properly accounted for by Angular. For example if a directive listens on DOM events, such as ng-click it must evaluate the expression inside the $apply method.

After evaluating the expression, the $apply method performs a $digest. In the $digest phase the scope examines all of the $watch expressions and compares them with the previous value. This dirty checking is done asynchronously. This means that assignment such as $scope.username="angular" will not immediately cause a $watch to be notified, instead the $watch notification is delayed until the $digest phase. This delay is desirable, since it coalesces multiple model updates into one $watch notification as well as guarantees that during the $watch notification no other $watches are running. If a $watch changes the value of the model, it will force additional $digest cycle.

Creation

The root scope is created during the application bootstrap by the $injector. During template linking, some directives create new child scopes.

Watcher registration

During template linking directives register watches on the scope. These watches will be used to propagate model values to the DOM.

Model mutation

For mutations to be properly observed, you should make them only within the scope.$apply(). Angular APIs do this implicitly, so no extra $apply call is needed when doing synchronous work in controllers, or asynchronous work with $http, $timeout or $interval services.

Mutation observation

At the end of $apply, Angular performs a $digest cycle on the root scope, which then propagates throughout all child scopes. During the $digest cycle, all $watched expressions or functions are checked for model mutation and if a mutation is detected, the $watch listener is called.

Scope destruction

When child scopes are no longer needed, it is the responsibility of the child scope creator to destroy them via scope.$destroy() API. This will stop propagation of $digest calls into the child scope and allow for memory used by the child scope models to be reclaimed by the garbage collector.


Dependency Injection: Just re-read the section.  There are a lot of software design principles here that I'm not fully comfortable with.  Here's the link: https://docs.angularjs.org/guide/di
 
Templates: templates are HTML docs that contain references to angular-specific elements and attributes

Expressions: Expressions are JS-like code snippets that are ussually place in double curly braces (bindings)

Filters:

Forms:

Directives:

One thing that I struggled with while starting angular practice was there was a huge learning curve just to get a simple app running.  Angular requires a web server to be running when you're working in test, because there is communication between files that is considered cross server scripting.

http://stackoverflow.com/questions/27742070/angularjs-error-cross-origin-requests-are-only-supported-for-protocol-schemes

